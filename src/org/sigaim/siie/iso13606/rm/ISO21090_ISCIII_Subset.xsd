<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://www.ascc.net/xml/schematron" xmlns:ns1="uri:iso.org:21090" targetNamespace="uri:iso.org:21090" elementFormDefault="qualified">
	<xsd:element name="OBJETO_AD" type="ns1:AD"/>
	<xsd:element name="OBJETO_ADXP" type="ns1:ADXP"/>
	<xsd:element name="OBJETO_ANY" type="ns1:ANY"/>
	<xsd:element name="OBJETO_BL" type="ns1:BL"/>
	<xsd:element name="OBJETO_CD" type="ns1:CD"/>
	<xsd:element name="OBJETO_CDCV" type="ns1:CD.CV"/>
	<xsd:element name="OBJETO_CO" type="ns1:CO"/>
	<xsd:element name="OBJETO_CS" type="ns1:CS"/>
	<xsd:element name="OBJETO_ED" type="ns1:ED"/>
	<xsd:element name="OBJETO_EDTEXT" type="ns1:ED.TEXT"/>
	<xsd:element name="OBJETO_EIVLTS" type="ns1:EIVL_TS"/>
	<xsd:element name="OBJETO_EIVLTSDATE" type="ns1:EIVL_TS.DATE"/>
	<xsd:element name="OBJETO_EIVLTSDATETIME" type="ns1:EIVL_TS.DATETIME"/>
	<xsd:element name="OBJETO_EN" type="ns1:EN"/>
	<xsd:element name="OBJETO_ENXP" type="ns1:ENXP"/>
	<xsd:element name="OBJETO_HXIT" type="ns1:HXIT"/>
	<xsd:element name="OBJETO_II" type="ns1:II"/>
	<xsd:element name="OBJETO_INT" type="ns1:INT"/>
	<xsd:element name="OBJETO_INTNONNEG" type="ns1:INT.NONNEG"/>
	<xsd:element name="OBJETO_INTPOS" type="ns1:INT.POS"/>
	<xsd:element name="OBJETO_IVLCO" type="ns1:IVL_CO"/>
	<xsd:element name="OBJETO_IVLHIGHCO" type="ns1:IVL.HIGH_CO"/>
	<xsd:element name="OBJETO_IVLHIGHINT" type="ns1:IVL.HIGH_INT"/>
	<xsd:element name="OBJETO_IVLHIGHMO" type="ns1:IVL.HIGH_MO"/>
	<xsd:element name="OBJETO_IVLHIGHPQ" type="ns1:IVL.HIGH_PQ"/>
	<xsd:element name="OBJETO_IVLHIGHPQTIME" type="ns1:IVL.HIGH_PQ.TIME"/>
	<xsd:element name="OBJETO_IVLHIGHREAL" type="ns1:IVL.HIGH_REAL"/>
	<xsd:element name="OBJETO_IVLHIGHRTO" type="ns1:IVL.HIGH_RTO"/>
	<xsd:element name="OBJETO_IVLHIGHTS" type="ns1:IVL.HIGH_TS"/>
	<xsd:element name="OBJETO_IVLHIGHTSDATE" type="ns1:IVL.HIGH_TS.DATE"/>
	<xsd:element name="OBJETO_IVLHIGHTSDATETIME" type="ns1:IVL.HIGH_TS.DATETIME"/>
	<xsd:element name="OBJETO_IVLINT" type="ns1:IVL_INT"/>
	<xsd:element name="OBJETO_IVLLOWCO" type="ns1:IVL.LOW_CO"/>
	<xsd:element name="OBJETO_IVLLOWINT" type="ns1:IVL.LOW_INT"/>
	<xsd:element name="OBJETO_IVLLOWMO" type="ns1:IVL.LOW_MO"/>
	<xsd:element name="OBJETO_IVLLOWPQ" type="ns1:IVL.LOW_PQ"/>
	<xsd:element name="OBJETO_IVLLOWPQTIME" type="ns1:IVL.LOW_PQ.TIME"/>
	<xsd:element name="OBJETO_IVLLOWREAL" type="ns1:IVL.LOW_REAL"/>
	<xsd:element name="OBJETO_IVLLOWRTO" type="ns1:IVL.LOW_RTO"/>
	<xsd:element name="OBJETO_IVLLOWTS" type="ns1:IVL.LOW_TS"/>
	<xsd:element name="OBJETO_IVLLOWTSDATE" type="ns1:IVL.LOW_TS.DATE"/>
	<xsd:element name="OBJETO_IVLLOWTSDATETIME" type="ns1:IVL.LOW_TS.DATETIME"/>
	<xsd:element name="OBJETO_IVLMO" type="ns1:IVL_MO"/>
	<xsd:element name="OBJETO_IVLPQ" type="ns1:IVL_PQ"/>
	<xsd:element name="OBJETO_IVLPQTIME" type="ns1:IVL_PQ.TIME"/>
	<xsd:element name="OBJETO_IVLREAL" type="ns1:IVL_REAL"/>
	<xsd:element name="OBJETO_IVLRTO" type="ns1:IVL_RTO"/>
	<xsd:element name="OBJETO_IVLTS" type="ns1:IVL_TS"/>
	<xsd:element name="OBJETO_IVLTSDATE" type="ns1:IVL_TS.DATE"/>
	<xsd:element name="OBJETO_IVLWIDTHCO" type="ns1:IVL.WIDTH_CO"/>
	<xsd:element name="OBJETO_IVLWIDTHTS" type="ns1:IVL.WIDTH_TS"/>
	<xsd:element name="OBJETO_IVLWIDTHTSDATE" type="ns1:IVL.WIDTH_TS.DATE"/>
	<xsd:element name="OBJETO_IVLTSDATETIME" type="ns1:IVL_TS.DATETIME"/>
	<xsd:element name="OBJETO_MO" type="ns1:MO"/>
	<xsd:element name="OBJETO_PIVLTS" type="ns1:PIVL_TS"/>
	<xsd:element name="OBJETO_PIVLTSDATE" type="ns1:PIVL_TS.DATE"/>
	<xsd:element name="OBJETO_PIVLTSDATETIME" type="ns1:PIVL_TS.DATETIME"/>
	<xsd:element name="OBJETO_PQ" type="ns1:PQ"/>
	<xsd:element name="OBJETO_PQR" type="ns1:PQR"/>
	<xsd:element name="OBJETO_PQTIME" type="ns1:PQ.TIME"/>
	<xsd:element name="OBJETO_PQV" type="ns1:PQV"/>
	<xsd:element name="OBJETO_QSDCO" type="ns1:QSD_CO"/>
	<xsd:element name="OBJETO_QSDINT" type="ns1:QSD_INT"/>
	<xsd:element name="OBJETO_QSDMO" type="ns1:QSD_MO"/>
	<xsd:element name="OBJETO_QSDPQ" type="ns1:QSD_PQ"/>
	<xsd:element name="OBJETO_QSDPQTIME" type="ns1:QSD_PQ.TIME"/>
	<xsd:element name="OBJETO_QSDREAL" type="ns1:QSD_REAL"/>
	<xsd:element name="OBJETO_QSDRTO" type="ns1:QSD_RTO"/>
	<xsd:element name="OBJETO_QSDTS" type="ns1:QSD_TS"/>
	<xsd:element name="OBJETO_QSDTSDATE" type="ns1:QSD_TS.DATE"/>
	<xsd:element name="OBJETO_QSDTSDATETIME" type="ns1:QSD_TS.DATETIME"/>
	<xsd:element name="OBJETO_QSETBOUNDEDPIVL" type="ns1:QSET.BOUNDEDPIVL"/>
	<xsd:element name="OBJETO_QSETCO" type="ns1:QSET_CO"/>
	<xsd:element name="OBJETO_QSETINT" type="ns1:QSET_INT"/>
	<xsd:element name="OBJETO_QSETMO" type="ns1:QSET_MO"/>
	<xsd:element name="OBJETO_QSETPQ" type="ns1:QSET_PQ"/>
	<xsd:element name="OBJETO_QSETPQTIME" type="ns1:QSET_PQ.TIME"/>
	<xsd:element name="OBJETO_QSETREAL" type="ns1:QSET_REAL"/>
	<xsd:element name="OBJETO_QSETRTO" type="ns1:QSET_RTO"/>
	<xsd:element name="OBJETO_QSETTS" type="ns1:QSET_TS"/>
	<xsd:element name="OBJETO_QSETTSDATE" type="ns1:QSET_TS.DATE"/>
	<xsd:element name="OBJETO_QSETTSDATETIME" type="ns1:QSET_TS.DATETIME"/>
	<xsd:element name="OBJETO_QSICO" type="ns1:QSI_CO"/>
	<xsd:element name="OBJETO_QSIINT" type="ns1:QSI_INT"/>
	<xsd:element name="OBJETO_QSIMO" type="ns1:QSI_MO"/>
	<xsd:element name="OBJETO_QSIPQ" type="ns1:QSI_PQ"/>
	<xsd:element name="OBJETO_QSIPQTIME" type="ns1:QSI_PQ.TIME"/>
	<xsd:element name="OBJETO_QSIREAL" type="ns1:QSI_REAL"/>
	<xsd:element name="OBJETO_QSIRTO" type="ns1:QSI_RTO"/>
	<xsd:element name="OBJETO_QSITS" type="ns1:QSI_TS"/>
	<xsd:element name="OBJETO_QSITSDATE" type="ns1:QSI_TS.DATE"/>
	<xsd:element name="OBJETO_QSITSDATETIME" type="ns1:QSI_TS.DATETIME"/>
	<xsd:element name="OBJETO_QSPCO" type="ns1:QSP_CO"/>
	<xsd:element name="OBJETO_QSPINT" type="ns1:QSP_INT"/>
	<xsd:element name="OBJETO_QSPMO" type="ns1:QSP_MO"/>
	<xsd:element name="OBJETO_QSPPQ" type="ns1:QSP_PQ"/>
	<xsd:element name="OBJETO_QSPPQTIME" type="ns1:QSP_PQ.TIME"/>
	<xsd:element name="OBJETO_QSPREAL" type="ns1:QSP_REAL"/>
	<xsd:element name="OBJETO_QSPRTO" type="ns1:QSP_RTO"/>
	<xsd:element name="OBJETO_QSPTS" type="ns1:QSP_TS"/>
	<xsd:element name="OBJETO_QSPTSDATE" type="ns1:QSP_TS.DATE"/>
	<xsd:element name="OBJETO_QSPTSDATETIME" type="ns1:QSP_TS.DATETIME"/>
	<xsd:element name="OBJETO_QSSCO" type="ns1:QSS_CO"/>
	<xsd:element name="OBJETO_QSSINT" type="ns1:QSS_INT"/>
	<xsd:element name="OBJETO_QSSMO" type="ns1:QSS_MO"/>
	<xsd:element name="OBJETO_QSSPQ" type="ns1:QSS_PQ"/>
	<xsd:element name="OBJETO_QSSPQTIME" type="ns1:QSS_PQ.TIME"/>
	<xsd:element name="OBJETO_QSSREAL" type="ns1:QSS_REAL"/>
	<xsd:element name="OBJETO_QSSRTO" type="ns1:QSS_RTO"/>
	<xsd:element name="OBJETO_QSSTS" type="ns1:QSS_TS"/>
	<xsd:element name="OBJETO_QSSTSDATE" type="ns1:QSS_TS.DATE"/>
	<xsd:element name="OBJETO_QSSTSDATETIME" type="ns1:QSS_TS.DATETIME"/>
	<xsd:element name="OBJETO_QSUCO" type="ns1:QSU_CO"/>
	<xsd:element name="OBJETO_QSUINT" type="ns1:QSU_INT"/>
	<xsd:element name="OBJETO_QSUMO" type="ns1:QSU_MO"/>
	<xsd:element name="OBJETO_QSUPQ" type="ns1:QSU_PQ"/>
	<xsd:element name="OBJETO_QSUPQTIME" type="ns1:QSU_PQ.TIME"/>
	<xsd:element name="OBJETO_QSUREAL" type="ns1:QSU_REAL"/>
	<xsd:element name="OBJETO_QSURTO" type="ns1:QSU_RTO"/>
	<xsd:element name="OBJETO_QSUTS" type="ns1:QSU_TS"/>
	<xsd:element name="OBJETO_QSUTSDATE" type="ns1:QSU_TS.DATE"/>
	<xsd:element name="OBJETO_QSUTSDATETIME" type="ns1:QSU_TS.DATETIME"/>
	<xsd:element name="OBJETO_QTY" type="ns1:QTY"/>
	<xsd:element name="OBJETO_REAL" type="ns1:REAL"/>
	<xsd:element name="OBJETO_RTO" type="ns1:RTO"/>
	<xsd:element name="OBJETO_SC" type="ns1:SC"/>
	<xsd:element name="OBJETO_ST" type="ns1:ST"/>
	<xsd:element name="OBJETO_STNT" type="ns1:ST.NT"/>
	<xsd:element name="OBJETO_TEL" type="ns1:TEL"/>
	<xsd:element name="OBJETO_TELURL" type="ns1:TEL.URL"/>
	<xsd:element name="OBJETO_TS" type="ns1:TS"/>
	<xsd:element name="OBJETO_TSDATE" type="ns1:TS.DATE"/>
	<xsd:element name="OBJETO_TSDATEFULL" type="ns1:TS.DATE.FULL"/>
	<xsd:element name="OBJETO_TSDATETIME" type="ns1:TS.DATETIME"/>
	<xsd:element name="OBJETO_TSDATETIMEFULL" type="ns1:TS.DATETIME.FULL"/>
	<xsd:element name="OBJETO_XReference" type="ns1:XReference"/>
	<xsd:simpleType name="NullFlavor">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="NI"/>
			<xsd:enumeration value="INV"/>
			<xsd:enumeration value="OTH"/>
			<xsd:enumeration value="NINF"/>
			<xsd:enumeration value="PINF"/>
			<xsd:enumeration value="UNC"/>
			<xsd:enumeration value="DER"/>
			<xsd:enumeration value="UNK"/>
			<xsd:enumeration value="ASKU"/>
			<xsd:enumeration value="NAV"/>
			<xsd:enumeration value="QS"/>
			<xsd:enumeration value="NASK"/>
			<xsd:enumeration value="TRC"/>
			<xsd:enumeration value="MSK"/>
			<xsd:enumeration value="NA"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="UpdateMode">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="A"/>
			<xsd:enumeration value="AU"/>
			<xsd:enumeration value="U"/>
			<xsd:enumeration value="R"/>
			<xsd:enumeration value="I"/>
			<xsd:enumeration value="D"/>
			<xsd:enumeration value="K"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="PostalAddressUse">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="H"/>
			<xsd:enumeration value="HP"/>
			<xsd:enumeration value="HV"/>
			<xsd:enumeration value="WP"/>
			<xsd:enumeration value="DIR"/>
			<xsd:enumeration value="PUB"/>
			<xsd:enumeration value="BAD"/>
			<xsd:enumeration value="TMP"/>
			<xsd:enumeration value="PHYS"/>
			<xsd:enumeration value="PST"/>
			<xsd:enumeration value="ABC"/>
			<xsd:enumeration value="IDE"/>
			<xsd:enumeration value="SYL"/>
			<xsd:enumeration value="SRCH"/>
			<xsd:enumeration value="SNDX"/>
			<xsd:enumeration value="PHON"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="AddressPartType">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="AL"/>
			<xsd:enumeration value="ADL"/>
			<xsd:enumeration value="UNID"/>
			<xsd:enumeration value="UNIT"/>
			<xsd:enumeration value="DAL"/>
			<xsd:enumeration value="DINST"/>
			<xsd:enumeration value="DINSTA"/>
			<xsd:enumeration value="DINSTQ"/>
			<xsd:enumeration value="DMOD"/>
			<xsd:enumeration value="DMODID"/>
			<xsd:enumeration value="SAL"/>
			<xsd:enumeration value="BNR"/>
			<xsd:enumeration value="BNN"/>
			<xsd:enumeration value="BNS"/>
			<xsd:enumeration value="STR"/>
			<xsd:enumeration value="STB"/>
			<xsd:enumeration value="STTYP"/>
			<xsd:enumeration value="DIR"/>
			<xsd:enumeration value="INT"/>
			<xsd:enumeration value="CAR"/>
			<xsd:enumeration value="CEN"/>
			<xsd:enumeration value="CNT"/>
			<xsd:enumeration value="CPA"/>
			<xsd:enumeration value="CTY"/>
			<xsd:enumeration value="DEL"/>
			<xsd:enumeration value="POB"/>
			<xsd:enumeration value="PRE"/>
			<xsd:enumeration value="STA"/>
			<xsd:enumeration value="ZIP"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="set_PostalAddressUse">
		<xsd:list itemType="ns1:PostalAddressUse"/>
	</xsd:simpleType>
	<xsd:simpleType name="Code">
		<xsd:restriction base="xsd:string"/>
	</xsd:simpleType>
	<xsd:simpleType name="CodingRationale">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="O"/>
			<xsd:enumeration value="P"/>
			<xsd:enumeration value="R"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="set_CodingRationale">
		<xsd:list itemType="ns1:CodingRationale"/>
	</xsd:simpleType>
	<xsd:simpleType name="Compression">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="DF"/>
			<xsd:enumeration value="GZ"/>
			<xsd:enumeration value="ZL"/>
			<xsd:enumeration value="Z"/>
			<xsd:enumeration value="BZ"/>
			<xsd:enumeration value="Z7"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="IntegrityCheckAlgorithm">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="SHA1"/>
			<xsd:enumeration value="SHA256"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="TelecommunicationAddressUse">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="H"/>
			<xsd:enumeration value="HP"/>
			<xsd:enumeration value="HV"/>
			<xsd:enumeration value="WP"/>
			<xsd:enumeration value="DIR"/>
			<xsd:enumeration value="PUB"/>
			<xsd:enumeration value="BAD"/>
			<xsd:enumeration value="TMP"/>
			<xsd:enumeration value="AS"/>
			<xsd:enumeration value="EC"/>
			<xsd:enumeration value="MC"/>
			<xsd:enumeration value="PG"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="set_TelecommunicationAddressUse">
		<xsd:list itemType="ns1:TelecommunicationAddressUse"/>
	</xsd:simpleType>
	<xsd:simpleType name="UncertaintyType">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="U"/>
			<xsd:enumeration value="N"/>
			<xsd:enumeration value="LN"/>
			<xsd:enumeration value="G"/>
			<xsd:enumeration value="E"/>
			<xsd:enumeration value="X2"/>
			<xsd:enumeration value="T"/>
			<xsd:enumeration value="F"/>
			<xsd:enumeration value="B"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="TimingEvent">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="HS"/>
			<xsd:enumeration value="AC"/>
			<xsd:enumeration value="ACM"/>
			<xsd:enumeration value="ACD"/>
			<xsd:enumeration value="ACV"/>
			<xsd:enumeration value="IC"/>
			<xsd:enumeration value="ICM"/>
			<xsd:enumeration value="ICD"/>
			<xsd:enumeration value="ICV"/>
			<xsd:enumeration value="PC"/>
			<xsd:enumeration value="PCM"/>
			<xsd:enumeration value="PCD"/>
			<xsd:enumeration value="PCV"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="EntityNameUse">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="C"/>
			<xsd:enumeration value="I"/>
			<xsd:enumeration value="L"/>
			<xsd:enumeration value="P"/>
			<xsd:enumeration value="A"/>
			<xsd:enumeration value="R"/>
			<xsd:enumeration value="OR"/>
			<xsd:enumeration value="SRCH"/>
			<xsd:enumeration value="PHON"/>
			<xsd:enumeration value="SNDX"/>
			<xsd:enumeration value="ABC"/>
			<xsd:enumeration value="SYL"/>
			<xsd:enumeration value="IDE"/>
			<xsd:enumeration value="ASGN"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="set_EntityNameUse">
		<xsd:list itemType="ns1:EntityNameUse"/>
	</xsd:simpleType>
	<xsd:simpleType name="EntityNamePartType">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="FAM"/>
			<xsd:enumeration value="GIV"/>
			<xsd:enumeration value="PFX"/>
			<xsd:enumeration value="SFX"/>
			<xsd:enumeration value="DEL"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="EntityNamePartQualifier">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="LS"/>
			<xsd:enumeration value="AC"/>
			<xsd:enumeration value="NB"/>
			<xsd:enumeration value="PR"/>
			<xsd:enumeration value="VV"/>
			<xsd:enumeration value="AD"/>
			<xsd:enumeration value="BR"/>
			<xsd:enumeration value="SP"/>
			<xsd:enumeration value="CL"/>
			<xsd:enumeration value="IN"/>
			<xsd:enumeration value="TITLE"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="set_EntityNamePartQualifier">
		<xsd:list itemType="ns1:EntityNamePartQualifier"/>
	</xsd:simpleType>
	<xsd:simpleType name="IdentifierScope">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="BUSN"/>
			<xsd:enumeration value="OBJ"/>
			<xsd:enumeration value="VER"/>
			<xsd:enumeration value="VW"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="IdentifierReliability">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="ISS"/>
			<xsd:enumeration value="VER"/>
			<xsd:enumeration value="UNV"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="Uid">
		<xsd:restriction base="xsd:string"/>
	</xsd:simpleType>
	<xsd:complexType name="BL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="value if not null">
					<sch:rule abstract="true" id="BL-0">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:attribute name="value" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="CO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="must have a code or a value">
					<sch:rule abstract="true" id="CO-0">
						<sch:assert test="@nullFlavor or (@value or (code and not(code/@nullFlavor)))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="CO-1">
						<sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no value if null">
					<sch:rule abstract="true" id="CO-2">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no code if null">
					<sch:rule abstract="true" id="CO-3">
						<sch:assert test="not(@nullFlavor) or (not code or code/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QTY">
				<xsd:sequence>
					<xsd:element name="code" type="ns1:CD" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="value" type="xsd:double" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="CS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="code is required">
					<sch:rule abstract="true" id="CS-0">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @code)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no code if null">
					<sch:rule abstract="true" id="CS-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@code))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:attribute name="code" type="xsd:string" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:simpleType name="CalendarCycle">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="CY"/>
			<xsd:enumeration value="MY"/>
			<xsd:enumeration value="CM"/>
			<xsd:enumeration value="CW"/>
			<xsd:enumeration value="WY"/>
			<xsd:enumeration value="DM"/>
			<xsd:enumeration value="CD"/>
			<xsd:enumeration value="DY"/>
			<xsd:enumeration value="DW"/>
			<xsd:enumeration value="HD"/>
			<xsd:enumeration value="CH"/>
			<xsd:enumeration value="NH"/>
			<xsd:enumeration value="CN"/>
			<xsd:enumeration value="SN"/>
			<xsd:enumeration value="CS"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="XReference">
		<xsd:attribute name="xref" type="xsd:IDREF" use="required"/>
	</xsd:complexType>
	<xsd:complexType name="AD">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null or parts">
					<sch:rule abstract="true" id="AD-0">
						<sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no useablePeriod if null">
					<sch:rule abstract="true" id="AD-1">
						<sch:assert test="not(@nullFlavor) or (not(thumbnail) or
useablePeriod\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on AD attributes">
					<sch:rule abstract="true" id="AD-2">
						<sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:choice minOccurs="0" maxOccurs="unbounded">
						<xsd:element name="part" type="ns1:ADXP"/>
						<xsd:element name="br" type="ns1:ADXP.BR"/>
						<xsd:element name="addressLine" type="ns1:ADXP.AL"/>
						<xsd:element name="additionalLocator" type="ns1:ADXP.ADL"/>
						<xsd:element name="unitID" type="ns1:ADXP.UNID"/>
						<xsd:element name="unitType" type="ns1:ADXP.UNIT"/>
						<xsd:element name="deliveryAddressLine" type="ns1:ADXP.DAL"/>
						<xsd:element name="deliveryInstallationType" type="ns1:ADXP.DINST"/>
						<xsd:element name="deliveryInstallationArea" type="ns1:ADXP.DINSTA"/>
						<xsd:element name="deliveryInstallationQualifier" type="ns1:ADXP.DINSTQ"/>
						<xsd:element name="deliveryMode" type="ns1:ADXP.DMOD"/>
						<xsd:element name="deliveryModeIdentifier" type="ns1:ADXP.DMODID"/>
						<xsd:element name="streetAddressLine" type="ns1:ADXP.SAL"/>
						<xsd:element name="houseNumber" type="ns1:ADXP.BNR"/>
						<xsd:element name="houseNumberNumeric" type="ns1:ADXP.BNN"/>
						<xsd:element name="buildingNumberSuffix" type="ns1:ADXP.BNS"/>
						<xsd:element name="streetName" type="ns1:ADXP.STR"/>
						<xsd:element name="streetNameBase" type="ns1:ADXP.STB"/>
						<xsd:element name="streetType" type="ns1:ADXP.STTYP"/>
						<xsd:element name="intersection" type="ns1:ADXP.INT"/>
						<xsd:element name="direction" type="ns1:ADXP.DIR"/>
						<xsd:element name="careOf" type="ns1:ADXP.CAR"/>
						<xsd:element name="censusTract" type="ns1:ADXP.CEN"/>
						<xsd:element name="country" type="ns1:ADXP.CNT"/>
						<xsd:element name="county" type="ns1:ADXP.CPA"/>
						<xsd:element name="city" type="ns1:ADXP.CTY"/>
						<xsd:element name="postBox" type="ns1:ADXP.POB"/>
						<xsd:element name="precinct" type="ns1:ADXP.PRE"/>
						<xsd:element name="state" type="ns1:ADXP.STA"/>
						<xsd:element name="postalCode" type="ns1:ADXP.ZIP"/>
					</xsd:choice>
					<xsd:element name="useablePeriod" type="ns1:QSET_TS" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="use" type="ns1:set_PostalAddressUse" use="optional"/>
				<xsd:attribute name="isNotOrdered" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP" mixed="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="value is required">
					<sch:rule abstract="true" id="ADXP-0">
						<sch:assert test="string-length(@value) &#62; 0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="code requires codeSystem">
					<sch:rule abstract="true" id="ADXP-1">
						<sch:assert test="@codeSystem or not(@code)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="codeSystemVersion only if codeSystem">
					<sch:rule abstract="true" id="ADXP-2">
						<sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:attribute name="code" type="xsd:string" use="optional"/>
		<xsd:attribute name="codeSystem" type="xsd:string" use="optional"/>
		<xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional"/>
		<xsd:attribute name="language" type="ns1:Code" use="optional"/>
		<xsd:attribute name="type" type="ns1:AddressPartType" use="optional"/>
	</xsd:complexType>
	<xsd:complexType name="ADXP.BR" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="DEL"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.AL" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="AL"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.ADL" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="ADL"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.UNID" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="UNID"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.UNIT" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="UNIT"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.DAL" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="DAL"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.DINST" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="DINST"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.DINSTA" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="DINSTA"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.DINSTQ" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="DINSTQ"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.DMOD" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="DMOD"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.DMODID" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="DMODID"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.SAL" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="SAL"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.BNR" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="BNR"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.BNN" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="BNN"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.BNS" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="BNS"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.STR" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="STR"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.STB" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="STB"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.STTYP" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="STTYP"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.INT" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="INT"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.DIR" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="DIR"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.CAR" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="CAR"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.CEN" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="CEN"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.CNT" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="CNT"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.CPA" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="CPA"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.CTY" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="CTY"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.POB" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="POB"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.PRE" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="PRE"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.STA" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="STA"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ADXP.ZIP" mixed="true">
		<xsd:complexContent mixed="true">
			<xsd:restriction base="ns1:ADXP">
				<xsd:attribute name="type" type="ns1:AddressPartType" fixed="ZIP"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET_TS" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_TS-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="TEL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="value is required">
					<sch:rule abstract="true" id="TEL-0">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no value if null">
					<sch:rule abstract="true" id="TEL-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no use if null">
					<sch:rule abstract="true" id="TEL-2">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@use))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no useablePeriod if null">
					<sch:rule abstract="true" id="TEL-3">
						<sch:assert test="not(@nullFlavor) or (not(thumbnail) or
useablePeriod\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on TEL attributes">
					<sch:rule abstract="true" id="TEL-4">
						<sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="useablePeriod" type="ns1:QSET_TS" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="value" type="xsd:anyURI" use="optional"/>
				<xsd:attribute name="use" type="ns1:set_TelecommunicationAddressUse" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="TEL.URL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="no use">
					<sch:rule abstract="true" id="TEL.URL-0">
						<sch:assert test="not(use)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="schemes">
					<sch:rule abstract="true" id="TEL.URL-1">
						<sch:assert test="(starts-with(@value, &#34;file&#34;) or starts-with(@value,
&#34;ftp&#34;) or starts-with(@value, &#34;http&#34;) or starts-with(@value, &#34;https&#34;)
or starts-with(@value, &#34;nfs&#34;))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:TEL">
				<xsd:sequence>
					<xsd:element name="useablePeriod" type="ns1:QSET_TS" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="use" type="ns1:TelecommunicationAddressUse" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ED">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="content is required if not null">
					<sch:rule abstract="true" id="ED-0">
						<sch:assert test="@nullFlavor or @value or xml or data"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="only one of value, data, xml">
					<sch:rule abstract="true" id="ED-1">
						<sch:assert test="count(*[self::value or self::xml or self::data])&#60;=1"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="integrityCheckAlgorithm required">
					<sch:rule abstract="true" id="ED-2">
						<sch:assert test="not(integrityCheck) or @integrityCheckAlgorithm"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="thumbnails do not use reference">
					<sch:rule abstract="true" id="ED-3">
						<sch:assert test="not(thumbnail) or thumbnail[not(@nullFlavor and reference)]"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="thumbnails do not have thumbnails">
					<sch:rule abstract="true" id="ED-4">
						<sch:assert test="not(thumbnail) or thumbnail[not(thumbnail)]"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="compression only on binary">
					<sch:rule abstract="true" id="ED-5">
						<sch:assert test="(@compression and data) or not(@compression or data)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="mediaType cannot be null">
					<sch:rule abstract="true" id="ED-6">
						<sch:assert test="@mediaType"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="value implies mediaType is text/plain">
					<sch:rule abstract="true" id="ED-7">
						<sch:assert test="not(@value) or (@value and (not(@mediaType) or @mediaType=&#39;text/plain&#39;))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no charset for value or xml">
					<sch:rule abstract="true" id="ED-8">
						<sch:assert test="not(@value or xml) or not(@charset)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="ED-9">
						<sch:assert test="count(*[self::reference or self::thumbnail][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no nested translations">
					<sch:rule abstract="true" id="ED-10">
						<sch:assert test="not(translation) or thumbnail[not(translation)]"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no value if null">
					<sch:rule abstract="true" id="ED-11">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no data if null">
					<sch:rule abstract="true" id="ED-12">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@data))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no xml if null">
					<sch:rule abstract="true" id="ED-13">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@xml))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no reference if null">
					<sch:rule abstract="true" id="ED-14">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@reference))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no mediaType if null">
					<sch:rule abstract="true" id="ED-15">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@mediaType))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no charset if null">
					<sch:rule abstract="true" id="ED-16">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@charset))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no language if null">
					<sch:rule abstract="true" id="ED-17">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@language))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no compression if null">
					<sch:rule abstract="true" id="ED-18">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@compression))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no integrityCheck if null">
					<sch:rule abstract="true" id="ED-19">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@integrityCheck))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no integrityCheckAlgorithm if null">
					<sch:rule abstract="true" id="ED-20">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@integrityCheckAlgorithm))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no thumbnail if null">
					<sch:rule abstract="true" id="ED-21">
						<sch:assert test="not(@nullFlavor) or (not(thumbnail) or thumbnail\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no translation if null">
					<sch:rule abstract="true" id="ED-22">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@translation))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="data" type="xsd:base64Binary" minOccurs="0"/>
					<xsd:element name="xml" type="xsd:anyType" minOccurs="0"/>
					<xsd:element name="reference" type="ns1:TEL.URL" minOccurs="0"/>
					<xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0"/>
					<xsd:element name="thumbnail" type="ns1:ED" minOccurs="0"/>
					<xsd:element name="description" type="ns1:ST" minOccurs="0"/>
					<xsd:element name="translation" type="ns1:ED" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
				<xsd:attribute name="value" type="xsd:string" use="optional"/>
				<xsd:attribute name="mediaType" type="xsd:string" use="optional" default="text/plain"/>
				<xsd:attribute name="charset" type="ns1:Code" use="optional"/>
				<xsd:attribute name="language" type="ns1:Code" use="optional"/>
				<xsd:attribute name="compression" type="ns1:Compression" use="optional"/>
				<xsd:attribute name="integrityCheckAlgorithm" type="ns1:IntegrityCheckAlgorithm" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ED.TEXT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="text only">
					<sch:rule abstract="true" id="ED.TEXT-0">
						<sch:assert test="@mediaType = &#34;&#39;text/plain&#39;&#34;"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no xml">
					<sch:rule abstract="true" id="ED.TEXT-1">
						<sch:assert test="not(xml)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no data">
					<sch:rule abstract="true" id="ED.TEXT-2">
						<sch:assert test="not(data)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no integrityCheck">
					<sch:rule abstract="true" id="ED.TEXT-3">
						<sch:assert test="not(integrityCheck)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no thumbnail">
					<sch:rule abstract="true" id="ED.TEXT-4">
						<sch:assert test="not(thumbnail)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no compression">
					<sch:rule abstract="true" id="ED.TEXT-5">
						<sch:assert test="not(@compression)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="ED.TEXT-6">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:ED">
				<xsd:sequence>
					<xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="xml" type="xsd:anyType" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="reference" type="ns1:TEL.URL" minOccurs="0"/>
					<xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="thumbnail" type="ns1:ED" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="description" type="ns1:ST" minOccurs="0"/>
					<xsd:element name="translation" type="ns1:ED" minOccurs="0" maxOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="mediaType" type="xsd:string" use="required" fixed="text/plain"/>
				<xsd:attribute name="compression" type="ns1:Compression" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="PIVL_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="period or frequency">
					<sch:rule abstract="true" id="PIVL_TS.DATE-0">
						<sch:assert test="not(period) or not(frequency)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PIVL attributes">
					<sch:rule abstract="true" id="PIVL_TS.DATE-1">
						<sch:assert test="count(*[self::phase or self::period][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATE">
				<xsd:sequence>
					<xsd:element name="phase" type="ns1:IVL_TS.DATE" minOccurs="0"/>
					<xsd:element name="period" type="ns1:PQ" minOccurs="0"/>
					<xsd:element name="frequency" type="ns1:RTO" minOccurs="0"/>
					<xsd:element name="count" type="ns1:INT.POS" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="alignment" type="ns1:CalendarCycle" use="optional"/>
				<xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="PQ">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="no translation if null">
					<sch:rule abstract="true" id="PQ-0">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@translation))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:PQV">
				<xsd:sequence>
					<xsd:element name="translation" type="ns1:PQR" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
				<xsd:attribute name="unit" type="ns1:Code" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ANY">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="no ANY unless null">
					<sch:rule abstract="true" id="ANY-0">
						<sch:assert test="todo"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:HXIT">
				<xsd:attribute name="nullFlavor" type="ns1:NullFlavor" use="optional"/>
				<xsd:attribute name="flavorId" type="xsd:string" use="optional"/>
				<xsd:attribute name="updateMode" type="ns1:UpdateMode" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="HXIT" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="extension requires root">
					<sch:rule abstract="true" id="HXIT-0">
						<sch:assert test="not(@controlActExtension) or @controlActRoot"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:attribute name="validTimeLow" type="xsd:string" use="optional"/>
		<xsd:attribute name="validTimeHigh" type="xsd:string" use="optional"/>
		<xsd:attribute name="controlActRoot" type="ns1:Uid" use="optional"/>
		<xsd:attribute name="controlActExtension" type="xsd:string" use="optional"/>
	</xsd:complexType>
	<xsd:complexType name="SC">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="no code if no value">
					<sch:rule abstract="true" id="SC-0">
						<sch:assert test="not(@nullFlavor) or (not(code) or (code/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on SC attributes">
					<sch:rule abstract="true" id="SC-1">
						<sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no originalText">
					<sch:rule abstract="true" id="SC-2">
						<sch:assert test="(not(originalText) or not(oroginalText/@nullFlavor)) or
(not(code) or (code/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ST">
				<xsd:sequence>
					<xsd:element name="code" type="ns1:CD" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ST">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="no nested translations">
					<sch:rule abstract="true" id="ST-0">
						<sch:assert test="not(translation) or thumbnail[not(translation)]"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="null or content">
					<sch:rule abstract="true" id="ST-1">
						<sch:assert test="(@nullFlavor or (@value and string-length(@value)&#38;gt;0)) and
not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="translation" type="ns1:ST.NT" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
				<xsd:attribute name="value" type="xsd:string" use="optional"/>
				<xsd:attribute name="language" type="ns1:Code" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ST.NT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="ST.NT-0">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:ST">
				<xsd:sequence>
					<xsd:element name="translation" type="ns1:ST.NT" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET_TS.DATE" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_TS.DATE-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null rules">
					<sch:rule abstract="true" id="IVL_TS.DATE-0">
						<sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor)
and (any|low|high|width))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="co-occurence rules">
					<sch:rule abstract="true" id="IVL_TS.DATE-1">
						<sch:assert test="(((any and not(any/@nullFlavor)) and not((low and
not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and
not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and
not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and
not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or
high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor))
or (high and not(high/@nullFlavor))))))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_TS.DATE-2">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_TS.DATE-3">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATE">
				<xsd:sequence>
					<xsd:element name="low" type="ns1:TS.DATE" minOccurs="0"/>
					<xsd:element name="high" type="ns1:TS.DATE" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:TS.DATE" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="TS-0">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QTY">
				<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9](\.[0-9]{1,4})?)?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="II">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="root is required">
					<sch:rule abstract="true" id="II-0">
						<sch:assert test="@nullFlavor or (not(@nullFlavor) and @root)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no root if null">
					<sch:rule abstract="true" id="II-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@root))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no extension if null">
					<sch:rule abstract="true" id="II-2">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@extension))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no identifierName if null">
					<sch:rule abstract="true" id="II-3">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@identifierName))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no displayable if null">
					<sch:rule abstract="true" id="II-4">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@displayable))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no reliability if null">
					<sch:rule abstract="true" id="II-5">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@reliability))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:attribute name="root" type="ns1:Uid" use="optional"/>
				<xsd:attribute name="extension" type="xsd:string" use="optional"/>
				<xsd:attribute name="identifierName" type="xsd:string" use="optional"/>
				<xsd:attribute name="displayable" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="scope" type="ns1:IdentifierScope" use="optional"/>
				<xsd:attribute name="reliability" type="ns1:IdentifierReliability" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="TS.DATE">
		<xsd:complexContent>
			<xsd:restriction base="ns1:TS">
				<xsd:sequence>
					<xsd:element name="expression" type="ns1:ED" minOccurs="0"/>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="uncertainty" type="ns1:QTY" minOccurs="0"/>
				</xsd:sequence>
			</xsd:restriction>
			<!--	<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}((0[1-9])|(1[0-2])((0[1-9])|([1-2][0-9]|3[0-1]))?)?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QTY" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="uncertainty">
					<sch:rule abstract="true" id="QTY-0">
						<sch:assert test="not(uncertainty/@expression) and not(uncertainty/@uncertainty)
and not(uncertainty/@originalText)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QTY-1">
						<sch:assert test="count(*[self::originalText or self::uncertainty or
self::expression][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension
or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="expression" type="ns1:ED" minOccurs="0"/>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="uncertainty" type="ns1:QTY" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="uncertaintyType" type="ns1:UncertaintyType" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="PQV">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="PQV-0">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no precision if null">
					<sch:rule abstract="true" id="PQV-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QTY">
				<xsd:sequence>
					<xsd:element name="source" type="ns1:XReference" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="value" type="xsd:double" use="optional"/>
				<xsd:attribute name="precision" type="xsd:int" use="optional" default="0"/>
				<xsd:attribute name="codingRationale" type="ns1:set_CodingRationale" use="optional"/>
				<xsd:attribute name="id" type="xsd:ID" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="PQR">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null or unit">
					<sch:rule abstract="true" id="PQR-0">
						<sch:assert test="todo"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no originalText">
					<sch:rule abstract="true" id="PQR-1">
						<sch:assert test="not(@originalText)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PQR">
					<sch:rule abstract="true" id="PQR-2">
						<sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and
not(@controlActRoot) and not(@controlActExtension) and not(@updateMode)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:PQV">
				<xsd:sequence>
					<xsd:element name="unit" type="ns1:CD.CV" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="CD">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null or code and/or originalText">
					<sch:rule abstract="true" id="CD-0">
						<sch:assert test="@nullFlavor or @code or (originalText and
not(originalText/@nullFlavor) or (originalTextReference and
not(originalTextReference/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="other requires codeSystem or valueSet">
					<sch:rule abstract="true" id="CD-1">
						<sch:assert test="@nullFlavor != &#34;OTH&#34; or @codeSystem or @valueSet"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="code requires codeSystem">
					<sch:rule abstract="true" id="CD-2">
						<sch:assert test="@codeSystem or not(@code)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="codeSystemName only if codeSystem">
					<sch:rule abstract="true" id="CD-3">
						<sch:assert test="@codeSystem or not(@codeSystemName)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="codeSystemVersion only if codeSystem">
					<sch:rule abstract="true" id="CD-4">
						<sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="displayName only if code">
					<sch:rule abstract="true" id="CD-5">
						<sch:assert test="@code or not(@displayName)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="valueSet requires valueSetVersion">
					<sch:rule abstract="true" id="CD-6">
						<sch:assert test="not(@valueSet) or (@valueSet and @valueSetVersion)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="No original text on translations">
					<sch:rule abstract="true" id="CD-7">
						<sch:assert test="not translation/originalText"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="Translations cannot have translations">
					<sch:rule abstract="true" id="CD-8">
						<sch:assert test="not translation/translation"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on CD elements">
					<sch:rule abstract="true" id="CD-9">
						<sch:assert test="count(*[self::displayName or self::originalText or
self::originalTextReference or self::translation][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no code if null">
					<sch:rule abstract="true" id="CD-10">
						<sch:assert test="not(@nullFlavor) or (not(thumbnail) or code\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no displayName if null">
					<sch:rule abstract="true" id="CD-11">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@displayName))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no source if null">
					<sch:rule abstract="true" id="CD-12">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@source))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="displayName" type="ns1:ST" minOccurs="0"/>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="translation" type="ns1:CD" minOccurs="0" maxOccurs="unbounded"/>
					<xsd:element name="source" type="ns1:XReference" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="code" type="xsd:string" use="optional"/>
				<xsd:attribute name="codeSystem" type="ns1:Uid" use="optional"/>
				<xsd:attribute name="codeSystemName" type="xsd:string" use="optional"/>
				<xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional"/>
				<xsd:attribute name="valueSet" type="xsd:string" use="optional"/>
				<xsd:attribute name="valueSetVersion" type="xsd:string" use="optional"/>
				<xsd:attribute name="codingRationale" type="ns1:set_CodingRationale" use="optional"/>
				<xsd:attribute name="id" type="xsd:ID" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="CD.CV">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="no translations">
					<sch:rule abstract="true" id="CD.CV-0">
						<sch:assert test="not(translation)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no source">
					<sch:rule abstract="true" id="CD.CV-1">
						<sch:assert test="not(@source)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:CD">
				<xsd:sequence>
					<xsd:element name="displayName" type="ns1:ST" minOccurs="0"/>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="translation" type="ns1:CD" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="source" type="ns1:XReference" minOccurs="0" maxOccurs="0"/>
				</xsd:sequence>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="RTO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="numerator and denominator required">
					<sch:rule abstract="true" id="RTO-0">
						<sch:assert test="@nullFlavor or ((numerator and not(numerator/@nullFlavor)) and
(numerator and not(numerator/@nullFlavor)))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on RTO Attributes">
					<sch:rule abstract="true" id="RTO-1">
						<sch:assert test="count(*[self::numerator or self::denominator][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no uncertainty">
					<sch:rule abstract="true" id="RTO-2">
						<sch:assert test="not(uncertainty)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QTY">
				<xsd:sequence>
					<xsd:element name="numerator" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="denominator" type="ns1:QTY" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="INT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="no uncertainty">
					<sch:rule abstract="true" id="INT-0">
						<sch:assert test="not(uncertainty)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="INT-1">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QTY">
				<xsd:attribute name="value" type="xsd:int" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="INT.POS">
		<xsd:complexContent>
			<xsd:restriction base="ns1:INT.NONNEG">
				<xsd:sequence>
					<xsd:element name="expression" type="ns1:ED" minOccurs="0"/>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="uncertainty" type="ns1:QTY" minOccurs="0"/>
				</xsd:sequence>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="INT.NONNEG">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not negative">
					<sch:rule abstract="true" id="INT.NONNEG-0">
						<sch:assert test="(@nullFlavor) or (@value &#62;= 0)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:INT">
				<xsd:sequence>
					<xsd:element name="expression" type="ns1:ED" minOccurs="0"/>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="uncertainty" type="ns1:QTY" minOccurs="0"/>
				</xsd:sequence>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="MO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="MO-0">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="null or currency">
					<sch:rule abstract="true" id="MO-1">
						<sch:assert test="(@nullFlavor or @currency) and not(@nullFlavor and @currency)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no precision if null">
					<sch:rule abstract="true" id="MO-2">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QTY">
				<xsd:attribute name="value" type="xsd:double" use="optional"/>
				<xsd:attribute name="precision" type="xsd:int" use="optional"/>
				<xsd:attribute name="currency" type="ns1:Code" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET_MO" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_MO-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSP_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_TS.DATE-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATE">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_TS.DATE" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_TS.DATE" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL_PQ.TIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null rules">
					<sch:rule abstract="true" id="IVL_PQ.TIME-0">
						<sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor)
and (any|low|high|width))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="co-occurence rules">
					<sch:rule abstract="true" id="IVL_PQ.TIME-1">
						<sch:assert test="(((any and not(any/@nullFlavor)) and not((low and
not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and
not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and
not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and
not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or
high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor))
or (high and not(high/@nullFlavor))))))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_PQ.TIME-2">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_PQ.TIME-3">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ.TIME">
				<xsd:sequence>
					<xsd:element name="low" type="ns1:PQ.TIME" minOccurs="0"/>
					<xsd:element name="high" type="ns1:PQ.TIME" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:PQ.TIME" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.LOW_PQ.TIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.LOW_PQ.TIME-0">
© 283
ISO 2008  All rights reserved
<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.LOW_PQ.TIME-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_PQ.TIME">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:PQ.TIME" minOccurs="0"/>
					<xsd:element name="high" type="ns1:PQ.TIME" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:PQ.TIME" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.HIGH_TS.DATETIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed =
&#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:TS.DATETIME" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:TS.DATETIME" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:TS.DATETIME" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL_MO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null rules">
					<sch:rule abstract="true" id="IVL_MO-0">
						<sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor)
and (any|low|high|width))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="co-occurence rules">
					<sch:rule abstract="true" id="IVL_MO-1">
						<sch:assert test="(((any and not(any/@nullFlavor)) and not((low and
not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and
not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and
not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and
not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or
high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor))
or (high and not(high/@nullFlavor))))))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_MO-2">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_MO-3">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_MO">
				<xsd:sequence>
					<xsd:element name="low" type="ns1:MO" minOccurs="0"/>
					<xsd:element name="high" type="ns1:MO" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:MO" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.LOW_MO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.LOW_MO-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.LOW_MO-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_MO">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:MO" minOccurs="0"/>
					<xsd:element name="high" type="ns1:MO" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:MO" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.LOW_REAL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.LOW_REAL-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.LOW_REAL-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_REAL">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:REAL" minOccurs="0"/>
					<xsd:element name="high" type="ns1:REAL" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:REAL" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL_RTO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null rules">
					<sch:rule abstract="true" id="IVL_RTO-0">
						<sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor)
and (any|low|high|width))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="co-occurence rules">
					<sch:rule abstract="true" id="IVL_RTO-1">
						<sch:assert test="(((any and not(any/@nullFlavor)) and not((low and
not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and
not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and
not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and
not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or
high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor))
or (high and not(high/@nullFlavor))))))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_RTO-2">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_RTO-3">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_RTO">
				<xsd:sequence>
					<xsd:element name="low" type="ns1:RTO" minOccurs="0"/>
					<xsd:element name="high" type="ns1:RTO" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:RTO" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL_REAL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null rules">
					<sch:rule abstract="true" id="IVL_REAL-0">
						<sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor)
and (any|low|high|width))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="co-occurence rules">
					<sch:rule abstract="true" id="IVL_REAL-1">
						<sch:assert test="(((any and not(any/@nullFlavor)) and not((low and
not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and
not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and
not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and
not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or
high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor))
or (high and not(high/@nullFlavor))))))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_REAL-2">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_REAL-3">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_REAL">
				<xsd:sequence>
					<xsd:element name="low" type="ns1:REAL" minOccurs="0"/>
					<xsd:element name="high" type="ns1:REAL" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:REAL" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL_TS.DATETIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null rules">
					<sch:rule abstract="true" id="IVL_TS.DATETIME-0">
						<sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor)
and (any|low|high|width))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="co-occurence rules">
					<sch:rule abstract="true" id="IVL_TS.DATETIME-1">
© 269
ISO 2008  All rights reserved
<sch:assert test="(((any and not(any/@nullFlavor)) and not((low and
not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and
not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and
not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and
not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or
high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor))
or (high and not(high/@nullFlavor))))))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_TS.DATETIME-2">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_TS.DATETIME-3">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="low" type="ns1:TS.DATETIME" minOccurs="0"/>
					<xsd:element name="high" type="ns1:TS.DATETIME" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:TS.DATETIME" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET_PQ.TIME" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_PQ.TIME-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET_RTO" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_RTO-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="PQ.TIME">
		<xsd:complexContent>
			<xsd:restriction base="ns1:PQ">
				<xsd:sequence>
					<xsd:element name="expression" type="ns1:ED" minOccurs="0"/>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="uncertainty" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="source" type="ns1:XReference" minOccurs="0"/>
					<xsd:element name="translation" type="ns1:PQR" minOccurs="0" maxOccurs="0"/>
				</xsd:sequence>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSD_PQ.TIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_PQ.TIME-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
© 315
ISO 2008  All rights reserved
</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ.TIME">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_PQ.TIME" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_PQ.TIME" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET_TS.DATETIME" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_TS.DATETIME-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET_REAL" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_REAL-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="TS.DATETIME">
		<xsd:complexContent>
			<xsd:restriction base="ns1:TS">
				<xsd:sequence>
					<xsd:element name="expression" type="ns1:ED" minOccurs="0"/>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="uncertainty" type="ns1:QTY" minOccurs="0"/>
				</xsd:sequence>
			</xsd:restriction>
			<!--	<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9])?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="REAL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null or value">
					<sch:rule abstract="true" id="REAL-0">
						<sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no precision if null">
					<sch:rule abstract="true" id="REAL-1">
						<sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QTY">
				<xsd:attribute name="value" type="xsd:double" use="optional"/>
				<xsd:attribute name="precision" type="xsd:int" use="optional" default="0"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSS_MO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_MO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_MO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_MO-2">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_MO-3">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_MO">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:MO" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.LOW_INT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.LOW_INT-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.LOW_INT-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_INT">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:INT" minOccurs="0"/>
					<xsd:element name="high" type="ns1:INT" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:INT" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL_INT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null rules">
					<sch:rule abstract="true" id="IVL_INT-0">
						<sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor)
and (any|low|high|width))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="co-occurence rules">
					<sch:rule abstract="true" id="IVL_INT-1">
						<sch:assert test="(((any and not(any/@nullFlavor)) and not((low and
not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and
not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and
not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and
not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or
high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor))
or (high and not(high/@nullFlavor))))))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_INT-2">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_INT-3">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_INT">
				<xsd:sequence>
					<xsd:element name="low" type="ns1:INT" minOccurs="0"/>
					<xsd:element name="high" type="ns1:INT" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:INT" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET_INT" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_INT-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSS_INT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_INT-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_INT-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_INT-2">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_INT-3">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_INT">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:INT" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="PIVL_TS.DATETIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="period or frequency">
					<sch:rule abstract="true" id="PIVL_TS.DATETIME-0">
						<sch:assert test="not(period) or not(frequency)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PIVL attributes">
					<sch:rule abstract="true" id="PIVL_TS.DATETIME-1">
						<sch:assert test="count(*[self::phase or self::period][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="phase" type="ns1:IVL_TS.DATETIME" minOccurs="0"/>
					<xsd:element name="period" type="ns1:PQ" minOccurs="0"/>
					<xsd:element name="frequency" type="ns1:RTO" minOccurs="0"/>
					<xsd:element name="count" type="ns1:INT.POS" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="alignment" type="ns1:CalendarCycle" use="optional"/>
				<xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSD_MO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_MO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_MO">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_MO" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_MO" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSD_REAL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_REAL-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_REAL">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_REAL" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_REAL" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.LOW_CO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.LOW_CO-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
© 279
ISO 2008  All rights reserved
<sch:rule abstract="true" id="IVL.LOW_CO-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_CO">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:CO" minOccurs="0"/>
					<xsd:element name="high" type="ns1:CO" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:CO" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL_CO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null rules">
					<sch:rule abstract="true" id="IVL_CO-0">
						<sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor)
and (any|low|high|width))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="co-occurence rules">
					<sch:rule abstract="true" id="IVL_CO-1">
						<sch:assert test="(((any and not(any/@nullFlavor)) and not((low and
not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and
not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and
not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and
not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or
high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor))
or (high and not(high/@nullFlavor))))))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_CO-2">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_CO-3">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_CO">
				<xsd:sequence>
					<xsd:element name="low" type="ns1:CO" minOccurs="0"/>
					<xsd:element name="high" type="ns1:CO" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:CO" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET_CO" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_CO-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSU_PQ.TIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_PQ.TIME-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_PQ.TIME-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ.TIME">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_PQ.TIME" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSS_CO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_CO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_CO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_CO-2">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_CO-3">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_CO">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:CO" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.HIGH_INT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.HIGH_INT-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed =
&#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.HIGH_INT-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_INT">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:INT" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:INT" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:INT" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSP_RTO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_RTO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_RTO">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_RTO" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_RTO" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.LOW_TS.DATETIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.LOW_TS.DATETIME-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.LOW_TS.DATETIME-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:TS.DATETIME" minOccurs="0"/>
					<xsd:element name="high" type="ns1:TS.DATETIME" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:TS.DATETIME" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.LOW_PQ">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.LOW_PQ-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.LOW_PQ-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_PQ">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:PQ" minOccurs="0"/>
					<xsd:element name="high" type="ns1:PQ" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:PQ" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL_PQ">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null rules">
					<sch:rule abstract="true" id="IVL_PQ-0">
						<sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor)
and (any|low|high|width))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="co-occurence rules">
					<sch:rule abstract="true" id="IVL_PQ-1">
						<sch:assert test="(((any and not(any/@nullFlavor)) and not((low and
not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and
not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and
not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and
not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or
high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor))
or (high and not(high/@nullFlavor))))))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_PQ-2">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_PQ-3">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ">
				<xsd:sequence>
					<xsd:element name="low" type="ns1:PQ" minOccurs="0"/>
					<xsd:element name="high" type="ns1:PQ" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:PQ" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET_PQ" abstract="true">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="No History or Update Mode">
					<sch:rule abstract="true" id="QSET_PQ-0">
						<sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="EIVL_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="EIVL_TS.DATE-0">
						<sch:assert test="@nullFlavor or (event)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on EIVL attributes">
					<sch:rule abstract="true" id="EIVL_TS.DATE-1">
						<sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATE">
				<xsd:sequence>
					<xsd:element name="offset" type="ns1:IVL_PQ" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="event" type="ns1:TimingEvent" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSD_RTO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_RTO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_RTO">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_RTO" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_RTO" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.LOW_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.LOW_TS-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.LOW_TS-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_TS">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:TS" minOccurs="0"/>
					<xsd:element name="high" type="ns1:TS" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:TS" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null rules">
					<sch:rule abstract="true" id="IVL_TS-0">
						<sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor)
and (any|low|high|width))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="co-occurence rules">
					<sch:rule abstract="true" id="IVL_TS-1">
						<sch:assert test="(((any and not(any/@nullFlavor)) and not((low and
not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and
not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and
not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and
not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or
high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor))
or (high and not(high/@nullFlavor))))))"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="closed attributes only if limited">
					<sch:rule abstract="true" id="IVL_TS-2">
						<sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on IVL attributes">
					<sch:rule abstract="true" id="IVL_TS-3">
						<sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS">
				<xsd:sequence>
					<xsd:element name="low" type="ns1:TS" minOccurs="0"/>
					<xsd:element name="high" type="ns1:TS" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:TS" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSP_INT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_INT-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_INT">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_INT" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_INT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="EIVL_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="EIVL_TS-0">
						<sch:assert test="@nullFlavor or (event)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on EIVL attributes">
					<sch:rule abstract="true" id="EIVL_TS-1">
						<sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS">
				<xsd:sequence>
					<xsd:element name="offset" type="ns1:IVL_PQ" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="event" type="ns1:TimingEvent" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSU_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_TS.DATE-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_TS.DATE-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATE">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_TS.DATE" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSD_CO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_CO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_CO">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_CO" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_CO" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSD_INT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_INT-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_INT">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_INT" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_INT" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSI_TS.DATETIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_TS.DATETIME-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_TS.DATETIME-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_TS.DATETIME" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="EN">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="null or parts">
					<sch:rule abstract="true" id="EN-0">
						<sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:ANY">
				<xsd:sequence>
					<xsd:element name="part" type="ns1:ENXP" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
				<xsd:attribute name="use" type="ns1:set_EntityNameUse" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ENXP">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="value is required">
					<sch:rule abstract="true" id="ENXP-0">
						<sch:assert test="string-length(@value) &#62; 0"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="code requires codeSystem">
					<sch:rule abstract="true" id="ENXP-1">
						<sch:assert test="@codeSystem or not(@code)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="codeSystemVersion only if codeSystem">
					<sch:rule abstract="true" id="ENXP-2">
© 229
ISO 2008  All rights reserved
<sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:attribute name="value" type="xsd:string" use="optional"/>
		<xsd:attribute name="code" type="xsd:string" use="optional"/>
		<xsd:attribute name="codeSystem" type="xsd:string" use="optional"/>
		<xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional"/>
		<xsd:attribute name="language" type="ns1:Code" use="optional"/>
		<xsd:attribute name="type" type="ns1:EntityNamePartType" use="optional"/>
		<xsd:attribute name="qualifier" type="ns1:set_EntityNamePartQualifier" use="optional"/>
	</xsd:complexType>
	<xsd:complexType name="QSS_RTO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_RTO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_RTO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_RTO-2">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_RTO-3">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_RTO">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:RTO" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSS_PQ.TIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_PQ.TIME-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_PQ.TIME-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_PQ.TIME-2">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_PQ.TIME-3">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ.TIME">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:PQ.TIME" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSU_REAL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_REAL-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_REAL-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_REAL">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_REAL" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSP_MO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_MO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_MO">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_MO" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_MO" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSD_PQ">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_PQ-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_PQ" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_PQ" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSS_PQ">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_PQ-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_PQ-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_PQ-2">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_PQ-3">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:PQ" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.HIGH_PQ.TIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.HIGH_PQ.TIME-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed =
&#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.HIGH_PQ.TIME-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_PQ.TIME">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:PQ.TIME" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:PQ.TIME" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:PQ.TIME" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSS_TS.DATETIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS.DATETIME-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS.DATETIME-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS.DATETIME-2">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS.DATETIME-3">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:TS.DATETIME" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSD_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_TS-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_TS" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_TS" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSS_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS-2">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS-3">
© 331
ISO 2008  All rights reserved
<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:TS" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSI_INT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_INT-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_INT-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_INT">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_INT" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.HIGH_CO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.HIGH_CO-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed =
&#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.HIGH_CO-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_CO">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:CO" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:CO" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:CO" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSS_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS.DATE-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS.DATE-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_TS.DATE-2">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_TS.DATE-3">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATE">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:TS.DATE" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSS_REAL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_REAL-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_REAL-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSS_REAL-2">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSS_REAL-3">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_REAL">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:REAL" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSD_TS.DATETIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_TS.DATETIME-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_TS.DATETIME" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_TS.DATETIME" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSI_RTO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_RTO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_RTO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_RTO">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_RTO" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSU_TS.DATETIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_TS.DATETIME-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_TS.DATETIME-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_TS.DATETIME" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.HIGH_PQ">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.HIGH_PQ-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed =
&#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.HIGH_PQ-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_PQ">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:PQ" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:PQ" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:PQ" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.HIGH_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.HIGH_TS-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed =
&#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.HIGH_TS-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_TS">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:TS" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:TS" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:TS" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSI_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_TS.DATE-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
© 317
ISO 2008  All rights reserved
</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_TS.DATE-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATE">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_TS.DATE" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSP_CO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_CO-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_CO">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_CO" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_CO" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.WIDTH_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.WIDTH_TS-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.WIDTH_TS-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.WIDTH_TS-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_TS">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:TS" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:TS" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:TS" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSI_PQ.TIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_PQ.TIME-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_PQ.TIME-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ.TIME">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_PQ.TIME" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.HIGH_REAL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.HIGH_REAL-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed =
&#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.HIGH_REAL-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_REAL">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:REAL" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:REAL" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:REAL" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSP_PQ">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_PQ-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_PQ" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_PQ" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSP_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_TS-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_TS" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_TS" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.HIGH_RTO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.HIGH_RTO-0">
© 295
ISO 2008  All rights reserved
<sch:assert test="high and not(high\@nullFlavor) and (@highClosed =
&#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.HIGH_RTO-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_RTO">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:RTO" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:RTO" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:RTO" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.WIDTH_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_TS.DATE">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:TS.DATE" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:TS.DATE" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:TS.DATE" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSP_TS.DATETIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_TS.DATETIME-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_TS.DATETIME" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_TS.DATETIME" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSET.BOUNDEDPIVL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="QSET.BOUNDEDPIVL 2">
					<sch:rule abstract="true" id="QSET.BOUNDEDPIVL-0">
						<sch:assert test="count(*)=2"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:QSI_TS">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="term" type="ns1:QSET_TS" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSI_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_TS-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_TS-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_TS" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="EIVL_TS.DATETIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="required attributes">
					<sch:rule abstract="true" id="EIVL_TS.DATETIME-0">
						<sch:assert test="@nullFlavor or (event)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on EIVL attributes">
					<sch:rule abstract="true" id="EIVL_TS.DATETIME-1">
						<sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or
@controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="offset" type="ns1:IVL_PQ" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="event" type="ns1:TimingEvent" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSI_PQ">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_PQ-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_PQ-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_PQ" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSI_REAL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_REAL-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_REAL-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_REAL">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_REAL" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSU_PQ">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_PQ-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_PQ-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_PQ" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSU_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_TS-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_TS-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_TS" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSI_MO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_MO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
© 319
ISO 2008  All rights reserved
<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_MO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_MO">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_MO" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.HIGH_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.HIGH_TS.DATE-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed =
&#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.HIGH_TS.DATE-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_TS.DATE">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:TS.DATE" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:TS.DATE" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:TS.DATE" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSU_MO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_MO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_MO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_MO">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_MO" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.WIDTH_CO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="width">
					<sch:rule abstract="true" id="IVL.WIDTH_CO-0">
						<sch:assert test="width and not(width\@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.WIDTH_CO-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.WIDTH_CO-2">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_CO">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:CO" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:CO" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0"/>
					<xsd:element name="any" type="ns1:CO" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSP_REAL">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_REAL-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_REAL">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_REAL" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_REAL" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSU_INT">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_INT-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_INT-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_INT">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_INT" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.LOW_RTO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.LOW_RTO-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.LOW_RTO-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_RTO">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:RTO" minOccurs="0"/>
					<xsd:element name="high" type="ns1:RTO" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:RTO" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="TS.DATETIME.FULL">
		<xsd:complexContent>
			<xsd:restriction base="ns1:TS.DATETIME">
				<xsd:sequence>
					<xsd:element name="expression" type="ns1:ED" minOccurs="0"/>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="uncertainty" type="ns1:QTY" minOccurs="0"/>
				</xsd:sequence>
			</xsd:restriction>
			<!--	<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}(0[1-9])|(1[0-2])(0[1-9])|([1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])[0-5][0-9][0-5][0-9]([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="PIVL_TS">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="period or frequency">
					<sch:rule abstract="true" id="PIVL_TS-0">
						<sch:assert test="not(period) or not(frequency)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="no updateMode or History on PIVL attributes">
					<sch:rule abstract="true" id="PIVL_TS-1">
						<sch:assert test="count(*[self::phase or self::period][@validTimeLow or
@validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS">
				<xsd:sequence>
					<xsd:element name="phase" type="ns1:IVL_TS" minOccurs="0"/>
					<xsd:element name="period" type="ns1:PQ" minOccurs="0"/>
					<xsd:element name="frequency" type="ns1:RTO" minOccurs="0"/>
					<xsd:element name="count" type="ns1:INT.POS" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="alignment" type="ns1:CalendarCycle" use="optional"/>
				<xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.LOW_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.LOW_TS.DATE-0">
						<sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.LOW_TS.DATE-1">
						<sch:assert test="not(high) and not(@highClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_TS.DATE">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:TS.DATE" minOccurs="0"/>
					<xsd:element name="high" type="ns1:TS.DATE" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:TS.DATE" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSP_PQ.TIME">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSP_PQ.TIME-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_PQ.TIME">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_PQ.TIME" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_PQ.TIME" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSU_RTO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_RTO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_RTO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_RTO">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_RTO" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSI_CO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSI_CO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSI_CO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_CO">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_CO" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="IVL.HIGH_MO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="high">
					<sch:rule abstract="true" id="IVL.HIGH_MO-0">
						<sch:assert test="high and not(high\@nullFlavor) and (@highClosed =
&#34;true&#34;)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="low">
					<sch:rule abstract="true" id="IVL.HIGH_MO-1">
						<sch:assert test="not(low) and not(@lowClosed)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:restriction base="ns1:IVL_MO">
				<xsd:sequence>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="low" type="ns1:MO" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="high" type="ns1:MO" minOccurs="0"/>
					<xsd:element name="width" type="ns1:QTY" minOccurs="0" maxOccurs="0"/>
					<xsd:element name="any" type="ns1:MO" minOccurs="0"/>
				</xsd:sequence>
				<xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
			</xsd:restriction>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSU_CO">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSU_CO-0">
						<sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
					</sch:rule>
				</sch:pattern>
				<sch:pattern name="size">
					<sch:rule abstract="true" id="QSU_CO-1">
						<sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_CO">
				<xsd:sequence>
					<xsd:element name="term" type="ns1:QSET_CO" minOccurs="0" maxOccurs="unbounded"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="QSD_TS.DATE">
		<xsd:annotation>
			<xsd:appinfo>
				<sch:pattern name="not null">
					<sch:rule abstract="true" id="QSD_TS.DATE-0">
						<sch:assert test="@nullFlavor or (not(first/@nullFlavor) and
not(second/@nullFlavor))"/>
					</sch:rule>
				</sch:pattern>
			</xsd:appinfo>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="ns1:QSET_TS.DATE">
				<xsd:sequence>
					<xsd:element name="first" type="ns1:QSET_TS.DATE" minOccurs="0"/>
					<xsd:element name="second" type="ns1:QSET_TS.DATE" minOccurs="0"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="TS.DATE.FULL">
		<xsd:complexContent>
			<xsd:restriction base="ns1:TS.DATE">
				<xsd:sequence>
					<xsd:element name="expression" type="ns1:ED" minOccurs="0"/>
					<xsd:element name="originalText" type="ns1:ED.TEXT" minOccurs="0"/>
					<xsd:element name="uncertainty" type="ns1:QTY" minOccurs="0"/>
				</xsd:sequence>
			</xsd:restriction>
			<!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="([1-2][0-9]{3,3}(0[1-9])|(1[0-2]))(0[1-9])|([1-2][0-9]|3[0-1])"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
		</xsd:complexContent>
	</xsd:complexType>
</xsd:schema>
